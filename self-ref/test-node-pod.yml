apiVersion: v1
kind: Service
metadata:
  name: www # this is mendatory field used for dns
  labels:
    name: www # any number of key and value
    env: staging
spec:
  selector: # forword traffic to where app: product
    app: product
  ports:
    - name: www
      #nodePort: 8080 # if not there kube will take random port for this
      port: 80 # all the consume will talk to service at this port
      targetPort: 3000 # todo change to be , service will forwrd traffic to this port (container port)
      protocol: TCP
  type: NodePort  #NodePort, LoadBalancer default is clusterIP

---

kind: Endpoints
apiVersion: v1
metadata:
  name: my-service
subsets:
  - addresses:
      - ip: 1.2.3.4  # todo some ip address where front end will hit
    ports:
      - port: 9376

---
apiVersion: v1.9.2
kind: Deployment  # this is nothing but, replica_set + pods, still have to create service for this
metadata:
  name: product
  namespace: default
spec:  # this is replica set
  replicas: 4 # create n number of pods
  template:
    metadata:
      labels:
        name: product  # select a pod with metadata label with name:product
    spec:
      containers:
        - name: product
          image: jugaljoshi/nginx-node-mysql-host
          resources:
          requests:
            cpu: 0.1 # 10% of 1 CPU core.
            memory: 200 # least 200Mb memory
          env:
            - name: ENV
              value: test
            - name: tets
              value: test
          ports:
          - name: http
            containerPort: 3306 # todo dynamic port, this will be exposed to outer
            protocol: TCP # or UDP

---

apiVersion: v1
kind: ReplicationController
metadata:
  name: web
  labels:
    name: web
    app: demo
spec:
  replicas: 2
  template:
    metadata:
      labels:
        name: web
    spec:
      containers:
        - name: web
          image: janakiramm/web
          ports:
            - containerPort: 5000
              name: http
              protocol: TCP


---
# data persistence

apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    name: nginx
    app: demo
spec:
  containers:
    - name: node-container
      image: nginx
      ports:
        - containerPort: 80
          name: http
          protocol: TCP
      volumeMounts:
        - mountPath: /usr/share/ngnix/html # path of container
          name: my-vol  # will live after pod kill
      #nodeSlector: node-1
  volumes:
    - name: my-vol
      persistentVolumeClaim:
        claimName: my-pvc

#      gcePersistentDisk:
#        pdName: my-vol
#        fsType: ext4



#      hostPath:
#        path: /home/jugal/my-local-vol # this is host machine path, if not there.. if will created


---

apiVersion: v1
kind: PersistentVolume
metadata:
  name: my-pv
  labels:
    name: local
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Recycle
  nfs:
    path: /opt/data/web # must be created before
    server: <server-app-id>

---

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---

apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        # Define the environment variable
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              # The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY
              name: special-config
              # Specify the key associated with the value
              key: special.how
        - name: LOG_LEVEL
            valueFrom:
              configMapKeyRef:
                name: special-config
                key: log_level
  restartPolicy: Never

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  log_level: INFO

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config-1
  namespace: default
data:
  SPECIAL_LEVEL: very
  SPECIAL_TYPE: charm

---

apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      envFrom:
      - configMapRef:
          name: special-config-1
  restartPolicy: Never


---
# Add ConfigMap data to a Volume
apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config-2
  namespace: default
data:
  special.level: very
  special.type: charm

---

apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod # =>| special-config-2
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "ls /etc/config/" ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config # ls /etc/config/  there will be two files special.level and special.type
  volumes:
    - name: config-volume
      configMap:
        # Provide the name of the ConfigMap containing the files you want
        # to add to the container
        name: special-config
  restartPolicy: Never


---

apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh","-c","cat /etc/config/keys" ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config # "cat /etc/config/keys" => very
  volumes:
    - name: config-volume
      configMap:
        name: special-config
        items:
        - key: special.level
          path: keys
  restartPolicy: Never

---

apiVersion: v1  # one way to use secret (as a file system, not a good way)
kind: Pod
metadata:
  name: secret-pod
spec:
  containers:
    - name: abc
      image: some-image
      volumeMounts:
        - name: secret-vol
          mountPath: "/etc/secret/
          readOnly: true
  volumes:
    - name: secret-vol
      secret:
        secretName: dbsecret # created by this command kubectl create secret generic
                            #dbsecret --from-file=./username.txt --from-file=./password.txt

---
# bttr way to create this # https://www.youtube.com/watch?v=GoITFljdJdo&index=9&list=PLF3s2WICJlqOiymMaTLjwwHz-MSVbtJPQ
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opeque
data:
  username: adfasfaf # echo admin | base64
  password: adafdadf  # echo password | base64


---
apiVersion: v1
kind: Pod
metadata:
  name: secret-pod2
spec:
  containers:
    - name: abc
      image: some-image
      env:
        - name: USER_NAME
          valueFrom:
            secretKeyRef:
              name: mysecret
              key: username
        - name: USER_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysecret
              key: password
  restartPolicy: Never



#            - name: PORT
#              value: "3000"
#            - name: DATABASE
#              value: "bigbasket"
#            - name: USER
#              value: "root"
#            - name: PASSWORD
#              value: "toor"
#            - name: HOST
#              value: "internal-service" # todo check this
#            - name: DIALECT
#              value: "mysql"
#            - name: DBPORT
#              value: "3306"